/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Data.hpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tda-silv <tda-silv@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/01/18 08:57:10 by tda-silv          #+#    #+#             */
/*   Updated: 2023/05/30 02:32:56 by tda-silv         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef DATA_HPP
# define DATA_HPP

# include <iomanip>
# include <list>
# include <stdio.h>
# include <stdlib.h>
# include <iostream>
# include <string>
# include <vector>
# include <map>
# include <algorithm>
# include <queue>
# include <cmath>
# include <array>

class Data
{
public:

	Data(void);
	Data(int my_base_index, int number_of_cells);
	Data(const Data &src);
	~Data(void);

	int									my_base_index;
	int									number_of_cells;
	int									total_ants;
	int									total_opp_ants;
	int									max_dist;
	int									beacon;
	int									egg_and_cryst;
	int									power_egg;
	std::vector<int>					list_base_index;
	std::vector<int>					res_by_dist;
	std::vector<int>					egg_by_dist;
	std::vector<int>					power_cell;
	std::vector<int>					beacon_this_loop;
	std::vector<int>					conected_to_base;
	std::vector<std::vector<int> >		conexions;
	std::map<int, std::vector<int> >	data_of_cells;
	std::vector<std::vector<int> >		dist_from_base;
	std::map<int, std::vector<int> >	dof_short_by_dist; // dof = data_of_cells
	std::list<std::list<int> >			path_to_base;

protected:

private:

};

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   header.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tda-silv <tda-silv@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/01/02 15:12:11 by tda-silv          #+#    #+#             */
/*   Updated: 2023/05/30 02:47:10 by tda-silv         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef HEADER_HPP
# define HEADER_HPP

# include <iomanip>
# include <list>
# include <stdio.h>
# include <stdlib.h>
# include <iostream>
# include <string>
# include <vector>
# include <map>
# include <algorithm>
# include <queue>
# include <cmath>
# include <array>

using namespace std;


void								start(Data &stock_data);
void								start_2(Data &stock_data);
void								algorithme_bfs(Data& stock_data, int origin, int max_dist, int index_base);
std::vector<int>					algorithme_bfs_2(Data& stock_data, int origin, int dest, int max_dist);
std::pair<int, int>					find_next_cell_conected(Data& stock_data, int origin, int max_dist);
std::pair<int, std::vector<int> >	find_next_res(Data& stock_data, int origin, int max_dist);
std::pair<int, std::vector<int> >	find_next_egg(Data& stock_data, int origin, int max_dist);
std::pair<int, std::vector<int> >	find_next_beacon(Data& stock_data, int origin, int max_dist, int index_base);
std::pair<int, std::vector<int> >	find_base(Data& stock_data, int origin, int max_dist);
int									my_line(Data &stock_data, int origin, int neighbor);
void								debug(Data &stock_data);
void								bfs_from_base(Data &stock_data);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Data.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tda-silv <tda-silv@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/01/18 08:58:53 by tda-silv          #+#    #+#             */
/*   Updated: 2023/05/29 17:47:09 by tda-silv         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


/* ************************************************************************** */
/*                                                                            */
/*   CONSTRUCTEUR															  */
/*                                                                            */
/* ************************************************************************** */
Data::Data(void)
{
	this->my_base_index = 0;
	this->number_of_cells = 0;
	this->total_ants = 0;
	this->total_opp_ants = 0;
	this->max_dist = 0;
	this->beacon = 0;
	this->egg_and_cryst = 0;
	this->power_egg = 2;
}

Data::Data(int my_base_index, int number_of_cells)
{
	this->my_base_index = my_base_index;
	this->number_of_cells = number_of_cells;
	this->total_ants = 0;
	this->max_dist = 0;
	for (int i = 0; i < number_of_cells; i++)
		for (int j = 0; j < 13; j++)
			this->data_of_cells[i].push_back(-1);
}

/*   COPY CONSTRUCTEUR   **************************************************** */

Data::Data(const Data &src)
{
	(void)src;
}

/* ************************************************************************** */
/*                                                                            */
/*   DESTRUCTEUR															  */
/*                                                                            */
/* ************************************************************************** */
Data::~Data(void)
{
}

/* ************************************************************************** */
/*                                                                            */
/*   OPÉRATEUR																  */
/*                                                                            */
/* ************************************************************************** */

/*   OPÉRATEUR INTERNE   **************************************************** */

/*   OPÉRATEUR EXTERNE   **************************************************** */

/* ************************************************************************** */
/*                                                                            */
/*   MÉTHODE																  */
/*                                                                            */
/* ************************************************************************** */

/*   MÉTHODE PUBLIC   ******************************************************* */

/*   MÉTHODE PRIVATE   ****************************************************** */

/* ************************************************************************** */
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   algorithme_bfs.cpp                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tda-silv <tda-silv@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/05/26 11:04:47 by tda-silv          #+#    #+#             */
/*   Updated: 2023/05/30 03:49:49 by tda-silv         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


void algorithme_bfs(Data& stock_data, int origin, int max_dist, int index_base)
{
	std::vector<bool> visited(stock_data.data_of_cells.size(), false);
	std::queue<std::pair<int, int> > bfs_queue;

	bfs_queue.push(std::pair<int, int>(origin, 0));
	visited[origin] = true;

	while (!bfs_queue.empty())
	{
		int index = bfs_queue.front().first;
		int dist = bfs_queue.front().second;
		bfs_queue.pop();

		stock_data.data_of_cells[index][8] = dist;
		stock_data.dist_from_base[index_base][index] = dist;
		if (dist < max_dist)
		{
			for (int j = 0; j < 6; j++)
			{
				int neighbor = stock_data.data_of_cells[index][j];
				if (neighbor != -1 && !visited[neighbor])
				{
					bfs_queue.push(std::pair<int, int>(neighbor, dist + 1));
					visited[neighbor] = true;
				}
			}
		}
	}
}

std::vector<int>	algorithme_bfs_2(Data& stock_data, int origin, int dest, int max_dist)
{
	std::vector<bool>					visited(stock_data.data_of_cells.size(), false);
	std::vector<int>					previous(stock_data.data_of_cells.size(), -1);
	std::queue<std::pair<int, int> >	bfs_queue;

	bfs_queue.push(std::pair<int, int>(origin, 0));
	visited[origin] = true;

	while (!bfs_queue.empty())
	{
		int index = bfs_queue.front().first;
		int dist = bfs_queue.front().second;
		bfs_queue.pop();

		if (index == dest)
		{
			std::vector<int>	path;
			int	current;

			current = dest;
		    while (current != origin)
            {
                path.push_back(current);
                current = previous[current];
            }
			path.push_back(origin);
			return (path);
		}
		if (dist < max_dist)
		{
			std::vector<int>	stock;

			for (int j = 0; j < 6; j++)
			{
				int neighbor = stock_data.data_of_cells[index][j];
				if (neighbor != -1 && !visited[neighbor])
				{
					bfs_queue.push(std::pair<int, int>(neighbor, dist + 1));
					visited[neighbor] = true;
					previous[neighbor] = index;
				}
			}
		}
	}
	return (std::vector<int>(0));
}

std::pair<int, int>	find_next_cell_conected(Data& stock_data, int origin, int max_dist)
{
	std::vector<bool> visited(stock_data.data_of_cells.size(), false);
	std::queue<std::pair<int, int> > bfs_queue;

	bfs_queue.push(std::pair<int, int>(origin, 0));
	visited[origin] = true;

	while (!bfs_queue.empty())
	{
		int index = bfs_queue.front().first;
		int dist = bfs_queue.front().second;
		bfs_queue.pop();

		if (dist < max_dist)
		{
			std::vector<int>	stock;
			
			for (int j = 0; j < 6; j++)
			{
				int neighbor = stock_data.data_of_cells[index][j];
				if (neighbor != -1 && !visited[neighbor])
				{
					if (stock_data.conected_to_base[neighbor] == true)
						return (std::pair<int, int>(neighbor, dist + 1));
					bfs_queue.push(std::pair<int, int>(neighbor, dist + 1));
					visited[neighbor] = true;
				}
			}
		}
	}
	return (std::pair<int, int>(-1, -1));
}

std::pair<int, std::vector<int> >	find_next_egg(Data& stock_data, int origin, int max_dist)
{
	std::vector<bool>					visited(stock_data.data_of_cells.size(), false);
	std::queue<std::pair<int, int> >	bfs_queue;
	std::vector<int>					path(stock_data.data_of_cells.size(), -1);

	bfs_queue.push(std::pair<int, int>(origin, 0));
	visited[origin] = true;

	while (!bfs_queue.empty())
	{
		int index = bfs_queue.front().first;
		int dist = bfs_queue.front().second;
		bfs_queue.pop();

		if (dist < max_dist)
		{
			std::vector<int>	stock;
			
			for (int j = 0; j < 6; j++)
			{
				int neighbor = stock_data.data_of_cells[index][j];
				if (neighbor != -1 && !visited[neighbor])
				{
					if (stock_data.data_of_cells[neighbor][6] == 1)
					{
						std::vector<int>	ret_path;
						int					path_neighbor = neighbor;

//						cerr << "neighbor["<< neighbor << "] " << index << " FIND !"<< endl;

						path[neighbor] = index;
						while (path_neighbor != origin)
						{
//							cerr << path_neighbor << " " << endl;
							ret_path.push_back(path_neighbor);
							path_neighbor = path[path_neighbor];
						}
						ret_path.push_back(path_neighbor);
//						cerr << path_neighbor << " " << endl;
	
						return (std::pair<int, std::vector<int> >(neighbor, ret_path));
					}
					bfs_queue.push(std::pair<int, int>(neighbor, dist + 1));
					visited[neighbor] = true;
//					cerr << "neighbor["<< neighbor << "] " << index << endl;
					path[neighbor] = index;
				}
			}
		}
	}
	return (std::pair<int, std::vector<int> >(-1, std::vector<int>()));
}

std::pair<int, std::vector<int> >	find_next_res(Data& stock_data, int origin, int max_dist)
{
	std::vector<bool>					visited(stock_data.data_of_cells.size(), false);
	std::queue<std::pair<int, int> >	bfs_queue;
	std::vector<int>					path(stock_data.data_of_cells.size(), -1);

	bfs_queue.push(std::pair<int, int>(origin, 0));
	visited[origin] = true;

	while (!bfs_queue.empty())
	{
		int index = bfs_queue.front().first;
		int dist = bfs_queue.front().second;
		bfs_queue.pop();

		if (dist < max_dist)
		{
			std::vector<int>	stock;
			
			for (int j = 0; j < 6; j++)
			{
				int neighbor = stock_data.data_of_cells[index][j];
				if (neighbor != -1 && !visited[neighbor])
				{
					if (stock_data.data_of_cells[neighbor][6] == stock_data.egg_and_cryst)
					{
						std::vector<int>	ret_path;
						int					path_neighbor = neighbor;

//						cerr << "neighbor["<< neighbor << "] " << index << " FIND !"<< endl;

						path[neighbor] = index;
						while (path_neighbor != origin)
						{
//							cerr << path_neighbor << " " << endl;
							ret_path.push_back(path_neighbor);
							path_neighbor = path[path_neighbor];
						}
						ret_path.push_back(path_neighbor);
//						cerr << path_neighbor << " " << endl;
	
						return (std::pair<int, std::vector<int> >(neighbor, ret_path));
					}
					bfs_queue.push(std::pair<int, int>(neighbor, dist + 1));
					visited[neighbor] = true;
//					cerr << "neighbor["<< neighbor << "] " << index << endl;
					path[neighbor] = index;
				}
			}
		}
	}
	return (std::pair<int, std::vector<int> >(-1, std::vector<int>()));
}

std::pair<int, std::vector<int> >	find_next_beacon(Data& stock_data, int origin, int max_dist, int index_base)
{
	std::queue<std::pair<int, int> >				bfs_queue;
	std::vector<bool>								visited(stock_data.data_of_cells.size(), false);
	std::vector<int>								path(stock_data.data_of_cells.size(), -1);
	std::vector<std::pair<int, std::vector<int> > >	list_beacons;

	bfs_queue.push(std::pair<int, int>(origin, 0));
	visited[origin] = true;
	while (!bfs_queue.empty())
	{
		int index = bfs_queue.front().first;
		int dist = bfs_queue.front().second;

		bfs_queue.pop();
		if (dist < max_dist)
		{
			std::vector<int>	stock;
			
			for (int j = 0; j < 6; j++)
			{
				int neighbor = stock_data.data_of_cells[index][j];

				if (neighbor != -1 && !visited[neighbor])
				{
					if (stock_data.beacon_this_loop[neighbor] || stock_data.conected_to_base[neighbor])
						list_beacons.push_back(std::pair<int, std::vector<int> >(neighbor, std::vector<int>()));
					bfs_queue.push(std::pair<int, int>(neighbor, dist + 1));
					visited[neighbor] = true;
					path[neighbor] = index;
				}
			}
			if (!list_beacons.empty())
			{
				for (size_t k = 0; k < list_beacons.size(); k++)
				{
					int	path_neighbor = list_beacons[k].first;
					
					path[list_beacons[k].first] = index;
					while (path_neighbor != origin)
					{
						list_beacons[k].second.push_back(path_neighbor);
						path_neighbor = path[path_neighbor];
					}
					list_beacons[k].second.push_back(path_neighbor);
				}
				int	save_index = -1;
				int	size_dist_from_base = 1000;

				for (size_t k = 0; k < list_beacons.size(); k++)
				{
					if (stock_data.dist_from_base[index_base][ list_beacons[k].first ] < size_dist_from_base)
					{
						save_index = k;
						size_dist_from_base = stock_data.data_of_cells[ list_beacons[k].first ][8];
					}
				}
				return (list_beacons[save_index]);
			}
		}
	}
	return (std::pair<int, std::vector<int> >(-1, std::vector<int>()));
}

std::pair<int, std::vector<int> >	find_base(Data& stock_data, int origin, int max_dist)
{
	std::vector<bool>					visited(stock_data.data_of_cells.size(), false);
	std::queue<std::pair<int, int> >	bfs_queue;
	std::vector<int>					path(stock_data.data_of_cells.size(), -1);

	bfs_queue.push(std::pair<int, int>(origin, 0));
	visited[origin] = true;
	while (!bfs_queue.empty())
	{
		int index = bfs_queue.front().first;
		int dist = bfs_queue.front().second;
		bfs_queue.pop();

		if (dist < max_dist)
		{
			std::vector<int>	stock;
			
			for (int j = 0; j < 6; j++)
			{
				int neighbor = stock_data.data_of_cells[index][j];
				if (neighbor != -1 && !visited[neighbor] && stock_data.power_cell[neighbor])
				{
					if (neighbor == stock_data.my_base_index)
					{
						std::vector<int>	ret_path;
						int					path_neighbor = neighbor;

						path[neighbor] = index;
						while (path_neighbor != origin)
						{
							ret_path.push_back(path_neighbor);
							path_neighbor = path[path_neighbor];
						}
						ret_path.push_back(path_neighbor);	
						return (std::pair<int, std::vector<int> >(neighbor, ret_path));
					}
					bfs_queue.push(std::pair<int, int>(neighbor, dist + 1));
					visited[neighbor] = true;
					path[neighbor] = index;
				}
			}
		}
	}
	return (std::pair<int, std::vector<int> >(-1, std::vector<int>()));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   start.cpp                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tda-silv <tda-silv@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/05/25 19:49:48 by tda-silv          #+#    #+#             */
/*   Updated: 2023/05/30 03:52:04 by tda-silv         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


void	start(Data &stock_data)
{
	cerr << "Start strat" << endl;
	cin >> stock_data.number_of_cells; cin.ignore();
	for (int i = 0; i < stock_data.number_of_cells; i++)
	{
		int type;				// 0 for empty, 1 for eggs, 2 for crystal
		int initial_resources;	// the initial amount of eggs/crystals on this cell
		int neigh_0;			// the index of the neighbouring cell for each direction or -1
		int neigh_1;
		int neigh_2;
		int neigh_3;
		int neigh_4;
		int neigh_5;
		cin
			>> type
			>> initial_resources
			>> neigh_0
			>> neigh_1
			>> neigh_2
			>> neigh_3
			>> neigh_4
			>> neigh_5;
		cin.ignore();
		stock_data.data_of_cells[i].push_back(neigh_0);				// [0]
		stock_data.data_of_cells[i].push_back(neigh_1);				// [1]
		stock_data.data_of_cells[i].push_back(neigh_2);				// [2]
		stock_data.data_of_cells[i].push_back(neigh_3);				// [3]
		stock_data.data_of_cells[i].push_back(neigh_4);				// [4]
		stock_data.data_of_cells[i].push_back(neigh_5);				// [5]
		stock_data.data_of_cells[i].push_back(type);				// [6]
		stock_data.data_of_cells[i].push_back(initial_resources);	// [7]
		stock_data.data_of_cells[i].push_back(-1);					// [8]  distance from my base
		stock_data.data_of_cells[i].push_back(-1);					// [9]  resources
		stock_data.data_of_cells[i].push_back(-1);					// [10] my_ants
		stock_data.data_of_cells[i].push_back(-1);					// [11] opp_ants
		stock_data.data_of_cells[i].push_back(-1);					// [12] case conected
		stock_data.data_of_cells[i].push_back(i);					// [13] real index 
	}

	int number_of_bases;
	cin >> number_of_bases; cin.ignore();

	for (int i = 0; i < number_of_bases; i++)
	{
		int base_index;
		
		cin >> base_index;
		cin.ignore();
		stock_data.my_base_index = base_index;
		stock_data.list_base_index.push_back(base_index);
	}

	for (int i = 0; i < number_of_bases; i++)
	{
		int opp_base_index;

		cin >> opp_base_index;
		cin.ignore();
	}

	for (int i = 0; i < stock_data.number_of_cells; i++)
	{
		stock_data.res_by_dist.push_back(0);
		stock_data.egg_by_dist.push_back(0);
		stock_data.power_cell.push_back(0);
		stock_data.beacon_this_loop.push_back(0);
		stock_data.conected_to_base.push_back(0);
		stock_data.conexions.push_back(std::vector<int>());
		stock_data.dist_from_base.push_back(std::vector<int>());
	}

	cerr << "Start bfs" << endl;
	for (size_t i = 0; i < stock_data.list_base_index.size(); i++)
	{
		for (int j = 0; j < stock_data.number_of_cells; j++)
			stock_data.dist_from_base[ stock_data.list_base_index[i] ].push_back(-1);
		algorithme_bfs(stock_data, stock_data.list_base_index[i], 20, stock_data.list_base_index[i]);

		stock_data.conected_to_base[stock_data.list_base_index[i]] = 1;
	}
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   start_2.cpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tda-silv <tda-silv@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/05/26 14:56:53 by tda-silv          #+#    #+#             */
/*   Updated: 2023/05/29 18:11:56 by tda-silv         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


void	start_2(Data &stock_data)
{
	if (stock_data.total_ants <= stock_data.total_opp_ants + 20)
	{
		stock_data.egg_and_cryst = 0;
		stock_data.power_egg = 5;
	}
	else
	{
		stock_data.egg_and_cryst = 1;
		stock_data.power_egg = 1;
	}

	stock_data.beacon = 0;
	stock_data.total_ants = 0;
	stock_data.total_opp_ants = 0;




	for (int i = 0; i < stock_data.number_of_cells; i++)
	{
		int resources;	// la quantité actuelle d'oeufs/cristaux sur cette cellule
		int my_ants;	// le montant de vos fourmis sur cette cellule
		int opp_ants;	// la quantité de fourmis adverses sur cette cellule
		cin
			>> resources
			>> my_ants
			>> opp_ants;
		cin.ignore();
		stock_data.data_of_cells[i][9] = resources;
		stock_data.data_of_cells[i][10] = my_ants;
		stock_data.data_of_cells[i][11] = opp_ants;
		stock_data.total_ants += my_ants;
		stock_data.total_opp_ants += opp_ants;
		if (resources > 0
			&& stock_data.data_of_cells[i][6] == 2
			&& stock_data.data_of_cells[i][8] > 0)							// [6] type == crystal [8] dist_from_base > 0
			stock_data.res_by_dist[stock_data.data_of_cells[i][8]] += 1;
		else if (resources > 0 && stock_data.data_of_cells[i][6] == 1)		// [6] type == egg
			stock_data.egg_by_dist[stock_data.data_of_cells[i][8]] += 1;
	}



	vector<pair<int, int> >	stock;

	for (int i = 0; i < stock_data.number_of_cells; i++)
	{
		stock.push_back(std::pair<int, int>(stock_data.data_of_cells[i][8], i));
	}
	sort(stock.begin(), stock.end());
	for (int i = 0; i < stock_data.number_of_cells; i++)
	{
		int	size;

		size = stock_data.data_of_cells[i].size();
		for (int j = 0; j < size; j++)
		{
			stock_data.dof_short_by_dist[i].push_back(stock_data.data_of_cells[stock[i].second][j]);
		}
	}



}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   my_line.cpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tda-silv <tda-silv@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/05/27 22:52:55 by tda-silv          #+#    #+#             */
/*   Updated: 2023/05/29 23:52:48 by tda-silv         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


int	my_line(Data &stock_data, int origin, int neighbor)
{	
	std::vector<int>	path;

	path = algorithme_bfs_2(stock_data, origin, neighbor, 10);

	if (stock_data.beacon + path.size() > (unsigned long int) stock_data.total_ants * 80 / 100)
		return (1);

	for (size_t i = 0; i < path.size(); i++)
	{
		cout << "BEACON" << " " << path[i] << " " << "1" << ";";
		stock_data.beacon_this_loop[path[i]] = 1;
		if (!stock_data.power_cell[path[i]])
			stock_data.beacon += 1;
		stock_data.power_cell[path[i]] = 1;
	}
	stock_data.conected_to_base[neighbor] = 1;
	stock_data.conected_to_base[origin] = 1;
	stock_data.conexions[origin].push_back(neighbor);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   bfs_from_base.cpp                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tda-silv <tda-silv@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/05/29 21:25:02 by tda-silv          #+#    #+#             */
/*   Updated: 2023/05/30 03:53:39 by tda-silv         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


int	empty_list_queue(std::vector<std::queue<std::pair<int, int> > >	list_queue);

void	visit_neighbors(
	Data &stock_data,
	std::queue<std::pair<int, int> > &bfs_queue,
	std::vector<bool> &visited,
	int base,
	int &index,
	int &dist,
	int j);



void	bfs_from_base(Data &stock_data)
{
	std::vector<std::queue<std::pair<int, int> > >	list_queue;
	std::vector<bool>								visited(stock_data.data_of_cells.size(), false);
	std::vector<int>								index2;
	std::vector<int>								dist2;

	for (size_t i = 0; i < stock_data.list_base_index.size(); i++)
	{
		list_queue.push_back(std::queue<std::pair<int, int> >());
		list_queue[i].push(std::pair<int, int>(stock_data.list_base_index[i] , 0));
		index2.push_back(-1);
		dist2.push_back(0);
		visited[stock_data.list_base_index[i]] = true;
	}

	while (!empty_list_queue(list_queue))
	{
		for (size_t i = 0; i < stock_data.list_base_index.size(); i++)
		{
			if (!list_queue[i].empty())
			{
				index2[i] = list_queue[i].front().first;
				dist2[i] = list_queue[i].front().second;

				list_queue[i].pop();
				for (size_t j = 0; j < 6; j++)
					visit_neighbors(stock_data, list_queue[i], visited, stock_data.list_base_index[i], index2[i], dist2[i], j);
			}
		}
	}
}




int	empty_list_queue(std::vector<std::queue<std::pair<int, int> > >	list_queue)
{
	for (size_t i = 0; i < list_queue.size(); i++)
	{
		if (!list_queue[i].empty())
			return (0);
	}
	return (1);
}

void	visit_neighbors(
	Data &stock_data,
	std::queue<std::pair<int, int> > &bfs_queue,
	std::vector<bool> &visited,
	int base,
	int &index,
	int &dist,
	int j)
{
	int	neighbor;

	neighbor = stock_data.data_of_cells[index][j];
	if (neighbor != -1 && !visited[neighbor])
	{
		bfs_queue.push(std::pair<int, int>(neighbor, dist + 1));
		visited[neighbor] = true;

//		cerr << "base: " << base << "\t\t" << index << " ] " << neighbor;
		if (stock_data.data_of_cells[neighbor][9] > 0 && stock_data.data_of_cells[neighbor][6] > 0)
		{
			std::pair<int, std::vector<int> > stock = find_next_beacon(stock_data, neighbor, 10, base);
			if (stock.first != -1)
			{
//				cerr << " | " << stock.first << " ---> " << neighbor << " (1)";
				my_line(stock_data, stock.first, neighbor);
			}
			else
			{
//				cerr << " | " << base << " ---> " << neighbor << " (2) " << stock.first << " " << stock.second.size();
				my_line(stock_data, base, neighbor);
			}
		}
//		cerr << endl;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   debug.cpp                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tda-silv <tda-silv@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/05/26 15:20:15 by tda-silv          #+#    #+#             */
/*   Updated: 2023/05/29 19:56:52 by tda-silv         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */



void	debug(Data &stock_data)
{
	cerr << "beacons :\t"<< stock_data.beacon << endl;
	cerr << "total_ants :\t"<< stock_data.total_ants << endl;
	cerr << "res_by_dist :\t";
	for (unsigned long int i = 0; i < stock_data.res_by_dist.size(); i++)
	{
		cerr << stock_data.res_by_dist[i] << " ";
		stock_data.res_by_dist[i] = 0;
	}
	cerr << endl;

	cerr << "egg_by_dist :\t";
	for (unsigned long int i = 0; i < stock_data.egg_by_dist.size(); i++)
	{
		cerr << stock_data.egg_by_dist[i] << " ";
		stock_data.egg_by_dist[i] = 0;
	}
	cerr << endl;

	cerr << "conexion :\n";
	for (unsigned long int i = 0; i < stock_data.conexions.size(); i++)
	{
		if (!stock_data.conexions[i].empty())
		{
			cerr << i << " :\t";
			for (unsigned long int j = 0; j < stock_data.conexions[i].size(); j++)
				cerr << stock_data.conexions[i][j] << " ";
			cerr << "\n";
			while (!stock_data.conexions[i].empty())
				stock_data.conexions[i].erase(stock_data.conexions[i].begin());
		}
	}
	cerr << endl;
	cout << endl;

	for (unsigned long int i = 0; i < stock_data.power_cell.size(); i++)
	{
//		cerr << i << " " << stock_data.pheromone[i] << endl;
		if (!stock_data.beacon_this_loop[i])
			stock_data.power_cell[i] = 0;
		stock_data.beacon_this_loop[i] = 0;
	}
	for (unsigned long int i = 0; i < stock_data.conected_to_base.size(); i++)
		stock_data.conected_to_base[i] = 0;
	stock_data.conected_to_base[stock_data.my_base_index] = 1;
//	stock_data.total_ants = 0;
//	stock_data.total_opp_ants = 0;
//	stock_data.beacon = 0; --> moove to start2.cpp
	stock_data.egg_and_cryst = 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tda-silv <tda-silv@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/05/25 19:46:21 by tda-silv          #+#    #+#             */
/*   Updated: 2023/05/30 00:28:25 by tda-silv         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


int main()
{
	Data					stock_data;
	unsigned long long int	i;

	i = 0;
	cerr << "Start main" << endl;
	start(stock_data);
	while (1)
	{	
		start_2(stock_data);
		cout << "MESSAGE" << " " << "Hello :)" << ";";
		bfs_from_base(stock_data);
		debug(stock_data);
		cerr << "-LOOP " << i <<  " -" << endl;
		i++;
	}
}

//		// [0]
//		// [1]
//		// [2]
//		// [3]
//		// [4]
//		// [5]
//		// [6]  type
//		// [7]  initial_resources
//		// [8]  distance from my base
//		// [9]  resources
//		// [10] my_ants
//		// [11] opp_ants
//		// [12] case conected
//		// [13] real index 
